"""Zellij theme generator"""

import re
from pathlib import Path
from .base import BaseApp
from utils import get_material_colors, get_catppuccin_colors, is_dynamic_theme


class ZellijTheme(BaseApp):
    """Zellij terminal multiplexer theme generator

    Generates theme inline in config.kdl for hot-reload support.

    Zellij only hot-reloads themes defined INLINE in config.kdl.
    Themes in separate files (themes/*.kdl) require restart.

    Architecture:
    - Dynamic themes: Inject theme block directly into config.kdl
    - Static themes: Use built-in Catppuccin (no generation needed)
    - Hot reload: Triggered by config.kdl file change
    """

    def __init__(self, config_home: Path):
        super().__init__("Zellij", config_home)
        self.config_file = config_home / "zellij/config.kdl"

    def apply_theme(self, theme_data: dict) -> None:
        """Apply theme to Zellij

        For dynamic themes: Inject theme block into config.kdl
        For static themes: Just log (built-in themes work automatically)

        Zellij hot-reloads when config.kdl changes.
        """
        if is_dynamic_theme(theme_data):
            self.inject_dynamic_theme(theme_data)
        else:
            # Static themes use Zellij's built-in Catppuccin
            theme_name = theme_data.get("theme", {}).get("name", "mocha")
            self.log_success(f"Using built-in theme: catppuccin-{theme_name}")

    def inject_dynamic_theme(self, theme_data: dict) -> None:
        """Inject dynamic theme block directly into config.kdl

        This enables hot-reload - Zellij watches config.kdl for changes.
        """
        self.log_progress("Injecting Zellij dynamic theme", emoji="ðŸ–¥ï¸")

        if not self.config_file.exists():
            self.log_warning(f"Zellij config not found: {self.config_file}")
            return

        mat = get_material_colors(theme_data)

        # Map Material colors to terminal ANSI colors
        colors = {
            "bg": mat.get("background", "#1e1e2e"),
            "fg": mat.get("on_surface", "#cdd6f4"),
            "black": mat.get("scrim", "#11111b"),
            "red": mat.get("error", "#f38ba8"),
            "green": mat.get("tertiary", "#a6e3a1"),
            "yellow": mat.get("secondary", "#f9e2af"),
            "blue": mat.get("primary", "#89b4fa"),
            "magenta": mat.get("primary", "#cba6f7"),
            "cyan": mat.get("tertiary", "#94e2d5"),
            "white": mat.get("on_surface", "#cdd6f4"),
            "orange": mat.get("secondary", "#fab387"),
        }

        theme_block = self._format_theme_block(colors)

        # Read current config
        content = self.config_file.read_text()

        # Check if themes block already exists
        # Pattern matches: themes { ... } with nested braces
        themes_pattern = (
            r"// --- DYNAMIC THEME START ---.*?// --- DYNAMIC THEME END ---\n?"
        )

        if re.search(themes_pattern, content, re.DOTALL):
            # Replace existing dynamic theme block
            new_content = re.sub(themes_pattern, theme_block, content, flags=re.DOTALL)
        else:
            # Append theme block at end
            new_content = content.rstrip() + "\n\n" + theme_block

        # Write back (triggers Zellij hot-reload)
        self.config_file.write_text(new_content)
        self.log_success("Zellij theme injected (hot-reload triggered)")

    def _format_theme_block(self, colors: dict) -> str:
        """Format theme as inline KDL block with markers for replacement"""
        return f"""// --- DYNAMIC THEME START ---
// Auto-generated by theme system - DO NOT EDIT between markers
themes {{
    dynamic {{
        bg "{colors["bg"]}"
        fg "{colors["fg"]}"
        red "{colors["red"]}"
        green "{colors["green"]}"
        yellow "{colors["yellow"]}"
        blue "{colors["blue"]}"
        magenta "{colors["magenta"]}"
        cyan "{colors["cyan"]}"
        orange "{colors["orange"]}"
        black "{colors["black"]}"
        white "{colors["white"]}"
    }}
}}
// --- DYNAMIC THEME END ---
"""

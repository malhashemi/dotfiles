"""NeoVim theme generator"""

from pathlib import Path
from .base import BaseApp
from utils import (
    get_material_colors,
    get_catppuccin_colors, 
    is_dynamic_theme,
    get_theme_variant,
)
from utils.hue_generator import (
    generate_ide_palette,
    generate_semantic_ansi,
    validate_hue_distribution,
)


class NvimTheme(BaseApp):
    """NeoVim text editor theme generator
    
    Generates three files for NeoVim's autocmd-based architecture:
    - colors-nvim.lua: 8-hue MD3 palette (dynamic) or empty (static)
    - theme-state.lua: Theme name and type for file watcher
    - opacity-data.lua: Opacity values for opacity-manager
    
    Method: external_file (multiple Lua modules)
    Reload: file_watch (automatic via autocmd, ~2s detection)
    
    Complexity: High (188 lines)
    - 8-hue palette generation with hue validation
    - Semantic ANSI color mapping
    - Three separate file outputs
    - Complex Lua formatting
    """
    
    def __init__(self, config_home: Path):
        super().__init__("NeoVim", config_home)
        self.colors_file = config_home / "nvim/lua/themes/colors-nvim.lua"
        self.state_file = config_home / "nvim/lua/themes/theme-state.lua"
        self.opacity_file = config_home / "nvim/lua/config/opacity-data.lua"
    
    def apply_theme(self, theme_data: dict) -> None:
        """Apply theme to NeoVim by generating all three files"""
        self.generate_colors(theme_data)
        self.generate_theme_state(theme_data)
        self.generate_opacity_data(theme_data)
        self._log_reload_instructions()
    
    def generate_colors(self, theme_data: dict) -> None:
        """Generate colors-nvim.lua with 8-hue palette or empty table
        
        For static themes: Returns empty dict (use builtin Catppuccin)
        For dynamic theme: Returns full MD3 palette with 8 distinct hues
        """
        self.log_progress("Generating NeoVim colors")
        
        theme = theme_data.get('theme', {})
        theme_name = theme.get('name', 'mocha')
        variant = get_theme_variant(theme_data)
        
        if is_dynamic_theme(theme_data):
            content = self._generate_dynamic_colors(theme_data, variant)
        else:
            content = self._generate_static_colors(theme_name)
        
        self.write_file(self.colors_file, content)
    
    def generate_theme_state(self, theme_data: dict) -> None:
        """Generate theme-state.lua for file watcher
        
        This tells NeoVim which theme to load on startup and whether
        it's a dynamic theme requiring the colors-nvim.lua palette.
        """
        theme = theme_data.get('theme', {})
        theme_name = theme.get('name', 'mocha')
        is_dynamic = theme_name == 'dynamic'
        
        content = f"""-- Neovim Theme State
-- Generated by theme-manager.py
-- This file tells Neovim which theme to load on startup

return {{
  theme_name = "{theme_name}",
  is_dynamic = {str(is_dynamic).lower()},
}}
"""
        
        self.write_file(self.state_file, content)
    
    def generate_opacity_data(self, theme_data: dict) -> None:
        """Generate opacity-data.lua for opacity-manager
        
        This is pure data consumed by opacity-manager.lua.
        Logic for applying opacity lives in NeoVim, not here.
        """
        theme = theme_data.get('theme', {})
        opacity_percent = theme.get('opacity', 0)
        opacity_float = opacity_percent / 100.0
        
        self.log_progress(f"Generating NeoVim opacity data ({opacity_percent}%)", emoji="ðŸ”")
        
        content = f"""-- Opacity Data
-- Generated by theme-manager.py
-- Used by opacity-manager.lua to apply opacity settings

return {{
  opacity = {opacity_float},
  opacity_percent = {opacity_percent},
}}
"""
        
        self.write_file(self.opacity_file, content)
    
    # Private helper methods
    
    def _generate_dynamic_colors(self, theme_data: dict, variant: str) -> str:
        """Generate Lua colors for dynamic MD3 theme
        
        Uses hue_generator to create 8 distinct hue families with validation.
        """
        mat = get_material_colors(theme_data)
        
        # Get base colors
        base_bg = mat.get('surface', '#1C1B1F')
        base_text = mat.get('on_surface', '#E6E1E5')
        
        # Generate 8-hue palette with proper contrast
        palette = generate_ide_palette(mat, variant, base_bg, base_text)
        
        # Generate semantic ANSI colors
        ansi = generate_semantic_ansi(palette)
        
        # Validate hue distribution
        validation = validate_hue_distribution(palette)
        if not validation['is_valid']:
            self.log_warning("Hue distribution may not be optimal")
            if validation['duplicates']:
                self.log_warning(f"Duplicate hues found: {len(validation['duplicates'])}")
        else:
            self.console.print("[green]âœ“ Validated 8 distinct hue families[/green]")
        
        # Format as Lua table
        return self._format_dynamic_lua(palette, ansi, variant, validation)
    
    def _generate_static_colors(self, theme_name: str) -> str:
        """Generate Lua colors for static Catppuccin theme
        
        Returns empty table - NeoVim uses builtin Catppuccin plugin.
        """
        return f"""-- Neovim Colors - Static Catppuccin {theme_name}
-- Generated by theme-manager.py
-- For static themes, use builtin Catppuccin plugin (no overrides needed)

return {{}}
"""
    
    def _format_dynamic_lua(
        self, 
        palette: dict, 
        ansi: dict, 
        variant: str,
        validation: dict
    ) -> str:
        """Format palette as Lua table with proper comments
        
        Includes hue distribution information for debugging.
        """
        # Format hue comments for documentation
        hue_comments = []
        for name, h, s, l in validation['hues']:
            hue_comments.append(
                f"  {name:12} = {palette[name]:8}  -- H:{h:6.1f}Â° S:{s:5.1f}% L:{l:5.1f}%"
            )
        
        return f"""-- Neovim Colors - Dynamic theme (Material Design 3)
-- Generated by theme-manager.py
-- Do not edit manually - changes will be overwritten
-- Variant: {variant}

local M = {{
  -- Base colors
  base = "{palette['base']}",
  mantle = "{palette['mantle']}",
  crust = "{palette['crust']}",
  
  -- Text hierarchy (WCAG AAA compliant)
  text = "{palette['text']}",
  subtext1 = "{palette['subtext1']}",
  subtext0 = "{palette['subtext0']}",
  
  -- Surface variants
  surface0 = "{palette['surface0']}",
  surface1 = "{palette['surface1']}",
  surface2 = "{palette['surface2']}",
  
  -- Overlays and borders
  overlay0 = "{palette['overlay0']}",
  overlay1 = "{palette['overlay1']}",
  overlay2 = "{palette['overlay2']}",
  
  -- 8 distinct hue families for IDE syntax
  red = "{palette['red']}",          
  maroon = "{palette['maroon']}",
  peach = "{palette['peach']}",      
  yellow = "{palette['yellow']}",    
  green = "{palette['green']}",      
  teal = "{palette['teal']}",
  sky = "{palette['sky']}",          
  sapphire = "{palette['sapphire']}",
  blue = "{palette['blue']}",        
  lavender = "{palette['lavender']}",
  mauve = "{palette['mauve']}",      
  pink = "{palette['pink']}",        
  flamingo = "{palette['flamingo']}",
  rosewater = "{palette['rosewater']}",
}}

-- Semantic ANSI colors (for terminal emulators)
M.ansi = {{
  -- Normal (ANSI 0-7)
  black = "{ansi['ansi_black']}",
  red = "{ansi['ansi_red']}",
  green = "{ansi['ansi_green']}",        -- Actual green!
  yellow = "{ansi['ansi_yellow']}",      -- Actual yellow!
  blue = "{ansi['ansi_blue']}",          -- Actual blue!
  magenta = "{ansi['ansi_magenta']}",
  cyan = "{ansi['ansi_cyan']}",
  white = "{ansi['ansi_white']}",
  
  -- Bright (ANSI 8-15)
  bright_black = "{ansi['ansi_bright_black']}",
  bright_red = "{ansi['ansi_bright_red']}",
  bright_green = "{ansi['ansi_bright_green']}",
  bright_yellow = "{ansi['ansi_bright_yellow']}",
  bright_blue = "{ansi['ansi_bright_blue']}",
  bright_magenta = "{ansi['ansi_bright_magenta']}",
  bright_cyan = "{ansi['ansi_bright_cyan']}",
  bright_white = "{ansi['ansi_bright_white']}",
}}

return M
"""
    
    def _log_reload_instructions(self) -> None:
        """Show NeoVim auto-reload message
        
        Note: Uses inline console.print like other apps for consistency.
        """
        self.console.print("[dim]  NeoVim will auto-reload when you switch back[/dim]")
